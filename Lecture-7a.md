# Lecture 7a: Обзор поздних тем

---

### `std::vector`

На прошлой неделе мы реализовывали вектор, но в языке он уже есть.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> x = {1, 2, 3, 4};
    x.push_back(11);
    x.pop_back();
    for (std::size_t i = 0; i < x.size(); i++)
    {
        std::cout << x[i] << " ";
    }
}
```

Выделение памяти требует обращения к системным библиотекам, затем к ОС, это не совсем дешевые операции, поэтому в программах где речь идет про производительность - стараются минимизировать выделение памяти, и реализация вектора во многом этому помогает.

```cpp
std::vector<int> x = {1, 2, 3, 4};
    x.pop_back();
    std::cout << "size: " << x.size() << ", capacity: " << x.capacity() << "\n";
    x.push_back(11);
    std::cout << "size: " << x.size() << ", capacity: " << x.capacity() << "\n";
```

```cpp
size: 3, capacity: 4
size: 4, capacity: 4
```

логический размер поменялся при добавлении элемента, а `capacity` - нет, это значит, что при удалении элемента - память не была перевыделена, что, собственно, логично. В большинстве случаев это хорошо, но может быть плохо, если у нас много векторов, и мы хотим сэкономить немного по памяти.

Можно попросить векотра уменьшить свой размер.

```cpp
std::vector<int> x = {1, 2, 3, 4};
    x.pop_back();
    x.shrink_to_fit();
    std::cout << "size: " << x.size() << ", capacity: " << x.capacity() << "\n";
    x.push_back(11);
    std::cout << "size: " << x.size() << ", capacity: " << x.capacity() << "\n";
```

Ветор в праве проигнорировать нас, но сейчас он нас послушал

```cpp
size: 3, capacity: 3
size: 4, capacity: 6
```

физический размер вырос в два раза. 

Единственная гарантированная возможность уменьшить размер вектора - это его скопировать, то есть например

```cpp
int main() {
    std::vector<int> x = {1, 2, 3, 4};
    x.pop_back();
    auto xx = x;
    std::cout << "size: " << xx.size() << ", capacity: " << xx.capacity() << "\n";
    xx.push_back(11);
    std::cout << "size: " << xx.size() << ", capacity: " << xx.capacity() << "\n";

    return 0;
}
```

```cpp
size: 3, capacity: 3
size: 4, capacity: 6
```

---

### `std::array`

```cpp
int main() {
    std::array<int, 4> x = {1, 2, 3, 4};
    for (std::size_t i = 0; i < x.size(); ++i)
    {
        std::cout << x[i] << " ";
    }
    return 0;
}
```

все так же как и с вектором, только размер статический и менять его на этапе исполнения - нельзя.

В чем разница с обычным массивом?

```cpp
int xx[4] = {1, 2, 3, 4};
```

В отличии от массива, объект `std::array` является полноценным объектом, можно копировать, перемещать, возвращать итд. То есть это пользаватьельский тип и его значение можно  использовать как значение базовых типов, в отличии от массивов, которые просто привязаны к области памяти и не всегда работают, как полноценные объекты.

---

### `std::string`

Мы на предыдущих лекция рассматривали вариант `char *str` , но это не слишком удобно, например, чтобы найти размер нам надо за линию пройтись и найти 0, или тоскать с собой дополнительную переменную, которая хранит в себе значение длины строки. Намного удобнее `std::string` 

Есть перегруженный оператор вывода в поток.

```cpp
void f(const std::string &str)
{
    std::cout << str << "\n";
}
```

есть метод для получения размера

```cpp
std::cout << str.size() << "\n";
```

Но эту строку можно менять, то есть она себя ведет, как динамический массив 

```cpp
void f(std::string &&str)
{
    str += '_';
    std::cout << str << "\n";
}
```

Представим, что у нас есть что-то такое

```cpp
int main() {
    std::array<std::string, 5> x;
}
```

Причем строки достаточно короткие, на самом деле если бы мы просто к ним часто обращались, то было бы удобнее иметь  

```cpp
char buf[50];
```

Для того чтобы не хранилось где-то глубоко в памяти, а хранилось в кэше, в который доступ быстрее.

Если б это был классический динамический массив, то выглядело бы это так

```cpp
std::array<std::pair<char *, std::size_t>, 5>, x>
```

Мы доступемся до какой-то строки, у нас в кэш попадает этот массив. Но мы на самом деле еще не допустились до нашей строки, сдедующим действием мы читаем указатель и обращаемся в память еще раз, снова что-то попадает в кэш, поработали со строкой, переходим к следующей строке и все повторяется заново. Вероятность того, что 2 или более строк, которые где-то лежат в памяти попадут вместе в кэш очень мала.

По этой причине, в современной реализации для строк применяется оптимизация, которая называется `short string optimization` . Работает для коротких строк, большие не попадут в кэш)

Возможно строка такая выглядит немного по другому внути 

```cpp
class String {
    char data[20];
    char *ptr = nullptr;
    std::size_t size = 0;
};
```

Зачем нам расходывать одновременно память на встроенный массив и на вещи связанные с динамическим массивом. Скорее всего там будет еще `union` . 

```cpp
class String {
    union {
        char data[20];
        std::pair<char *, std::size_t> dyn;
    };
};
```

`union` позволяет расходывать память только на максимальный по размеру элемент,  при этом, можно пользоваться только одним из элементов `union` . Другими словами, у нас мб есть несколько сущностей, у которых время жизни никогда не пересекается, и мы пользуемся либо одним, либо другим, а память расходуем как-будто они лежали в одной области памяти. 

Из такой реализиции следует, что операция перемещения становится не такой дешевой, какой она была для динамического массива, мы будем всегда копировать такие короткие строки, если строки длинные, то там операция будет по прежнему дешевой.

---

### `# include <string_view>`

Предположим в нашей программе есть какой-то объем строковых данных, которые как-то хравнятся, и есть большой объем операций над этими строками, которые эти строки не меняют, более того, которые даже не меняют перечень  этих строк.

Мы, конечно, можем передавать эти строки по ссылке

```cpp
void f(const std::string & str)
{
}
```

Если нам нужно физически хранить эти строки в одном месте, а в многих других местах ссылаться на них, и нам хочется сохранить это в каких-то объектах, но это уже не так удобно.

```cpp
struct X {
    const std::string & str;
	};
```

Присвавания у такого класса не будет, а только инициализация. Если понадобится еще копировать эти объекты (в плане присваивания), то нам уже ссылки не подойдут, придется перейти на указатели, все становится достаточно сложно. Теперь представим, что нам надо работать с подстроками, причем сами строки не меняются, подстроки придется скопировать 

```cpp
std::string f(const std::string & str)
{
    return str.substr(5, 10);
}
```

Казалось бы достаточно просто сослаться на ту или иную подстроку. Для этого сущетсвует класс `string_view` . На самом деле это что-то, что имеет примерно такой вид

```cpp
struct StringView {
    const char *ptr;
    std::size_t size;
};
```

То есть это указатель и размер. Засчет того, что тут есть размер `StringView` может представлять собой кусок строки, который не завершается нулевым символом. То есть теперь можем написать 

```cpp
std::string_view f(std::string_view str)
{
    return str.substr(5, 10);
}
```

можем хранить как поле какого-то объекта

```cpp
struct X {
    std::string_view str;
};
```

### `std::reference_wrapper`

Предположим, мы хотим сослаться на какой-то другой объект. Это может быть ссылка, а может и указатель со всеми своими последствиями. Что если хочется, чтобы с точки зрения копирования, он себя вел как указатель, а с  точки зрения того, что он всегда куда-то указывает - как ссылка, для этого есть `std::reference_wrapper` . Чтобы его использовать надо подключить `#include <functional>` 

```cpp
struct X {
    std::reference_wrapper<Y> y;
};
```

Он копируется, и поэтому он ведет себя в точности, как указатель, но проинициализировать его можно только ссылкой на объект, в нем всегда что-то будет.

---

### Вернемся к нашему классу `array`

У него нет эффективной операции перемещения. Очевидно, что мы можем передать его куда-то по ссылке, тем самым избежать копирование, но что если мы хотим не только передать его для чтения, но и передать его для записи. Может быть время жизни нашего объекта логически истекает, и мы хотим отдать его куда-то. C `array` такого не получится, перемещения у него эффективно нет. Что если мы хотим его вернуть из функции, как бы мы могли написать, если бы мы не думали про эффективность копирования. Можно написать как-то вот так вот

 

```cpp
std::array<int, 10> v()
{
    std::array<int, 10> x;
    /* ... */
    return x;
}
```

Сразу еще можно написать аналогичный пример для вектора 

```cpp
std::vector<int> w()
{
    std::vector<int> x;
    /* ... */
    return x;
}
```

Н.о для векотра уже есть эффективная операция перемещения.

Должны ли мы сказать что-то такое компилятору, чтобы намекнуть ему на перемещение, ну с другой стороны как-то странно, вроде бы очевидная ситуация. 

```cpp
return std::move(x);
```

Понятно, что эту ситуаци. можно было разрулить по другому, а именно

```cpp
void k(std::array<int, 10> & x)
{
		/* ... */
}
```

Мы передаем ссылку на объект, в этой функции его наполняем, вызывающий код получает это значение. Но это немного не удобно, в том плане, что нарушается логическая простота, то что мы из функции хотим получитб какое-то значение. Придется заводить переменную, итп…

Вспомним, что такое копирование или перемещение в случае сложных типов. В случае сложных типов - это вызов конструктора. Здесь появляется желание немного соптимизировать в этом месте. 

На самом деле компилятор действительно догадается в той ситуации заюзать операцию перемещения, а не копирования (для `array` не имеет смысла, для вектора имеет). Компилятор поймет, что с одной стороны это не временный объект, с другой стороны это локальная переменная в функции, ее время жизни подходит к концу, мы можем ее переместить. 

Но на самом деле стандарт пошел дальше. Стандарт разрешает компилятору не делать ни копирование, ни перемещение.

```cpp
int main() {
    auto x = w();
}
```

Он разрешает компилятору сгенерировать код таким образом, что в процессе вызова нашей функции `w` , этот объект, который был у нас переменной `x` (в самой функции), потом или копируем, или перемещаем наружу, он будет создан сразу в нужном месте, там, где мы его ожидаем в вызывающем коде. 

А что если это был наш класс у которого мы в конструкторе перемещения написали печать в поток?  А тут печати не будет, мы нарушаем тут правило ожидаемого поведения программы, и это исключение из этого правила, то есть стандарт разрешает компилятору в таком случае нарушать это правило и менять наблюдаемое поведение программы.

В 17м стандарте появилась не только оптимизация, но и правило, которому обязаны следовать все корректные компиляторы.

Если у нас в return стоит какое-то выражение, из которого можно сконструктурировать результат нашей функции, то компилятор обязан скомпилировать код таким образом, чтобы никакие конструкторы копирования/перемещения не вызывались 

```cpp
std::vector<int> g()
{
    return {1, 2, 3, 4};
}
```

То есть у нас объект сразу создан будет в нужном месте в вызывающем коде. То есть в функции `g` он требует это от компилятора, а в функции `w` это является оптимизацией. Оптимизация называется NRVO, а требование - copy elision

---

### Немного о другом

Предположим мы пишем дерево, в котором узлы не являются равноправными, то есть у нас есть несколько типов узлов в этом дереве. Предположим у нас есть листья и внутренние узлы и данные, которые они хранят чем то отличаются. Как бы мы могли такое дерево представить? 

```cpp
#include <iostream>
#include <vector>

// Node is an interface
class Node
{
public:
    std::vector<Node *> get_children() const { return {}; };
    bool is_leaf() const { return false; };
};

class Internal : public Node
{
    std::vector<Node *> m_children;
public:
    std::vector<Node *> get_children() const
    {
        return m_children;
    }
    bool is_leaf() const
    {
        return false;
    }

};

class Leaf : public Node
{
public:
    std::vector<Node *> get_children() const
    {
        return {};
    }
    bool is_leaf() const
    {
        return true;
    }
};

class Tree
{
    Node *m_root = nullptr;
public:
    Tree(const int)
        :m_root(new Leaf)
    {

    }
    void traverse()
    {
        if (m_root != nullptr)
        {
            if (m_root->is_leaf())
            {
                std::cout << "leaf\n";
            }
            else
            {
                for (const auto *ptr: m_root->get_children())
                {
                    std::cout << (ptr->is_leaf() ? "leaf" : "internal");
                }
            }
        }
    }
};

int main()
{
    Tree tree(1);
    tree.traverse();
}
```

мы не знаем на этапе компиляции будет ли это `internal` либо же это `leaf` , но мы хотим вызвать корректную реализацию

Ничего не напечаталось, не смотря на то что у нас есть один лист, это значит, что зашло сюда

```cpp
// Node is an interface
class Node
{
public:
    std::vector<Node *> get_children() const { return {}; };
    bool is_leaf() const { return false; };
};
```

У нас все работает неправильно. Механизм, который нам здесь нужен не будет бесплатным, потому что нам здесь нужно хранить какую-то информацию, но на этапе исполнения, поэтому программист должен это заказывать явно и называется это виртуальными функциями. 

```cpp
// Node is an interface
class Node
{
public:
    virtual std::vector<Node *> get_children() const { return {}; };
    virtual bool is_leaf() const { return false; };
};
```

Теперь у нас все заработало. Когда мы помечаем функцию виртуальной, во всех потомках, если мы определяем функцию с тем же именем и с теми же параметрами, то она тоже становится виртуальной и это называется перегрузкой (Переопределением)виртуальной функции. У нас в каждои нашем объекте классов, где у нас появились виртуальные функции будет храниться доп информация, чтобы на этапе исполнения мы могли определить с каким объектом мы на самом деле имеем дело и вызвать для него корректную реализацию той или иной виртуальной функции. В данном случае мы работаем с `Node` а вызывается класс `Leaf` . 

Это называется динамическим полиморфизмом, то есть полиморфизм на этапе исполнения, когда мы можем работать с разными объектами через какой-то общий интерфейс, мы должны за это заплатить, можно ожидать, что для каждого объекта класса в иерархии которого есть хотя бы одна виртуальная функция мы заплатим указателем, то есть в каждлм объекте нашего класса будет лежать еще один невидимый для нас указатель. Этот указатель будет указывать на специальную таблицу связанную с каждым классом, то есть на каждый класс еще и таблица) В этих таблицах будут иденфицироваться все виртуальные функции этого класса и там будут указатели на нужную реализацию.  

Когда мы думали, что хуже не станет - оно стало. На самом деле мы не только указателем в каждом объекте нашего класса, мы заплатим более дорогим вызовом наших виртуальных функций (мы будем платить только за вызов самих **виртуальных** функций)

---

Напишем деструктор для нашего дерева

```cpp
~Tree() 
{
    delete m_root;
}
```

Сейчас наша программа немного не корректна. У нас есть указатель на `Node` , мы можем присвоить ему указатель на его потомка. Но когда мы удаляем этот объект, компилятор смотрит на тип указателя, в этом случае он смотрит на указатель на `Node` , а значит, нужно вызвать дуструктор класса `Node` , которого еще нет, давайте его напишем.

```cpp
~Node() {
    std::cout << "~Node\n";
}
```

а то что мы в классе Leaf напишем деструктор

```cpp
~Leaf() {
    std::cout << "~Leaf\n";
}
```

в данным момент этот деструктор ничего полезного не делает, если хотим можем в него просто добавить какую-то информацию

```cpp
class Leaf : public Node
{
    char * m_payload = nullptr;
public:

    Leaf()
        : m_payload(new char[100]) {}
    std::vector<Node *> get_children() const
    {
        return {};
    }
    bool is_leaf() const
    {
        return true;
    }

    ~Leaf() {
        std::cout << "~Leaf\n";
        delete [] m_payload;
    }
};
```

А на самом деле тут то тоже утечка памяти, правда не на столько заметная. Дело все в том, что деструктор это тоже функция, и чтобы получить изоморфизм на деструкторах надо их тоже сделать виртуальными 

<aside>
💡 Мораль: если у нас в программе есть динамический полиморфизм, то в любой иерархии классов для которого он имеет смысл, в корне этой иерархии стоит сделать виртуальный деструктор. Во всех потомках, даже если не напишем, то компилятор определит это самостоятельно.

</aside>

---

## `code:`

```cpp
#include <iostream>
#include <vector>

// Node is an interface
class Node
{
public:
    virtual std::vector<Node *> get_children() const { return {}; };
    virtual bool is_leaf() const { return false; };

    virtual ~Node() {
        std::cout << "~Node\n";
    }
};

class Internal : public Node
{
    std::vector<Node *> m_children;
public:
    std::vector<Node *> get_children() const
    {
        return m_children;
    }
    bool is_leaf() const
    {
        return false;
    }

};

class Leaf : public Node
{
    char * m_payload = nullptr;
public:

    Leaf()

        : m_payload(new char[100]) {}
    std::vector<Node *> get_children() const
    {
        return {};
    }
    bool is_leaf() const
    {
        return true;
    }

    virtual ~Leaf() {
        std::cout << "~Leaf\n";
        delete [] m_payload;
    }
};

class Tree
{
    Node *m_root = nullptr;
public:
    Tree(const int)
        :m_root(new Leaf)
    {

    }
    void traverse()
    {
        if (m_root != nullptr)
        {
            if (m_root->is_leaf())
            {
                std::cout << "leaf\n";
            }
            else
            {
                for (const auto *ptr: m_root->get_children())
                {
                    std::cout << (ptr->is_leaf() ? "leaf" : "internal");
                }
            }
        }
    }

    virtual ~Tree()
    {
        delete m_root;
    }
};

int main()
{
    Tree tree(1);
    tree.traverse();
}
```